This provides an extension of jBPM that enables CMMN runtime semantics.
It currently supports the following features


1. CaseFileItem events generated from either JCR/Jackrabbit-OCM or JPA/Hibernate
There are currently two supported persistence engines: JPA on top of Hibernate and Jackrabbit's OCM on top of JCR. Both these approaches require child CaseFileItems to be named after the properties 
in the class that represents the parent CaseFileItem. The domain model hierarchy implemented by developers in Java therefore needs to reflect the CaseFileItem hierarchy defined in the CaseFile. The example domain that
we used was define in UML and both the CaseFile as well as the Java domain model were generated from a UML model. However, this is not a requirement, it just made testing easier.

1.1.JPA/Hibernate
We leverage Hibernate's eventing architecture to generate events. Signaling events this way has a slight performance impact. Under certain circumstances, specifically with the CasefFileItem.ADD_XXX and
CaseFileItem.REMOVE_XXX transitions, unininitalized lazy loaded collections need to be initialized to determine membership. Events are delivered synchronously which means that the implementation of 
the case itself will affect the performance of Hibernate.  

1.2. Jackrabbit OCM on JCR
Since Case Management is often used in conjunction with content management, it made sense to support JCR. Events are generated by the JCR implementation from a standard JCR EventListener. Our first implementation
only supports a JCR content repository that is mapped to Java classes defined in a normal Java domain model. Support for pure JCR without a Java domain model is theoretically possible and may be implemented in future.
OCM is a bit slow when compared to Hibernate due to the lack of session based caching, and JCR does not allow us to extract and reconstruct deleted information in certain event scenarios. The current implementation requires a very
specific mapping of the Java domain model to the JCR content repository. We followed OCM best practice of defining "holder" content types for Collections. The example content repository structure we used was generated
from the same UML model as the code, but again this is not a requirement.

2. Subscription to events generated by the persistence engines
There are two supported mechanisms for subscribing to events, and both are supported for JCR/OCM as well as JPA/Hibernate

2.1. Demarcated subscription
This mechanism requires developers to programmatically stipulate when the persistence engine (JPA/JCR) should deliver events to subscriptions from a CaseInstance, and when it should stop doing this. 
Developers would typically activate the subscriptions before execution of of Task (Human, Case  or Process) transitions (claim,close,cancel,resume,etc), and then deactivate them afterwards.
This can be done using the static methods on the DemarcatedSubscriptionContent class. Subscriptions are activated and stored temporarily in ThreadLocal variables, and need to be cleaned up afterwards. This mechanism has less
performance overheads on the persistence engines, and allows subscriptions to be more fine-grained. However, events occurring outside of the demarcated subscription context will not be delivered to any case instance.
 
2.2. Persistent subscription
This mechanism stores subscriptions to domain entities as they become relevant during the execution of the case instance, and removes them as they become irrelevant again. Most caseFileItem transitions are stored against
the object generating them. The only exceptions are CREATE and DELETE which are stored against the object representing the parent object of the created or deleted object in the domain model. This mechanism is very powerful,
as it supports delivery of events from practically any context. However, it does introduce performance overheads, which can become problematic if many case instances subscribe to the same object. 

3. Expressions.
In CMMN, expressions are used to define PlanItem rules (e.g. automatic activation of tasks, completion requirement rules, repeat rules) and read/write of caseFileItems (parameter transformations, bindingRefinements).
As with jBPM, this CMMN implementation supports expressions in CMMN defined in either Java or MVEL. In a concurrent project, we have also implemented support for OCL (Object Constraint Language), but this would 
require a UML model representing the Java domain model. The Java domain model can be generated from the UML model, but we are also working on the possibility of dynamically reversing the Java domain code to UML. 
This would obviate the need for the UML model. All expression languages are dynamically compiled at runtime. The OCL implementation generates Java code which is then compiled at runtime using jBPM's built-in support
for Java.

4. Human Tasks
CMMN Human Tasks are implemented using the standard jBPM TaskService. The relevant PlanItemEvents are generated from the task service as well, but unfortunately there are events in CMMN that are not supported by the
WS Human Task lifecycle implemented in jBPM, such as activate/deactivation which typically occurs during the planning process.

5. Stages
Unlike embedded subprocesses in jBPM, Stages in CMMN require human intervention almost like normal Human Tasks. As a result, we instantiate a Task in the jBPM task service representing the Stage, and the idea is that
we would be using this task to suspend, resume, and complete a Stage. This task can also be used for planning activities such as explicit role and/or parameter assignment for specific tasks, or enabling/disabling 
Discretionary items.
 
6. Milestones
7. UserEventListeners
8. TimerEventListeners
9. CaseTasks
10. ProcessTasks

11. Notes on implementation.
11.1. PlanItem instance classes
We initially intended to use the existing jBPM instance classes. However CMMN defines very specific lifecycle requirements for PlanItems. As a result, we decided to implement PlanItem instance class for each type of
PlanItemDefinition that could be used to define a PlanItem. The CaseInstanceMarshaller class ensures that they are all persisted correctly.
11.2. Persistence
CMMN has no limit on the multiplicity of CaseFileItems and CaseParameters. As a result, we need to implement support for collections in the form of ObjectMarshallingStrategies. During suscription demarcation, we 
also require a close relationship with the persistence context to refine even handling, but we are still ironing out the complexities of this. 
11.3. Diagramming
No final decisions have been made regarding diagramming. There are obvious benefits to using the Kie workebench and its built Oryx modeler. However, the primary purpose of this CMMN implementation is for the 
Ifu Lobuntu online collaboration offering. In this specific case, CMMN models and the associated UML and VDML models would be established collaboratively, which fits more intuitively with web content management systems 
such as Jahia, Hippo and Magnolia, all of which use JCR and jBPM. In such a scenario, it may make more sense to leverage the content management facilities (versioning, checking out, checkin in, workflows, polling, 
comments, etc). Ideally there would be a way to make this work at least with the Oryx modeler from the Kie Workbench, but it is unlike that we would be able to integrate Kie as a whole into Jahia, for instance






  